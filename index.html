<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 15px;
            background: #f2f2f2;
        }

        .card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            margin: auto;
        }

        h3 {
            text-align: center;
        }

        input,
        select,
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px;
        }

        textarea {
            width: 95%;
            padding: 10px;
            margin-top: 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            margin-top: 12px;
        }

        button:active {
            opacity: 0.8;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
</head>

<body>

    <div class="card">
        <h3>Crypto Demo Tool</h3>

        <label>Plain Text</label>
        <textarea id="plain" rows="3"></textarea>

        <label>Algorithm</label>
        <select id="algo">
            <option>DES</option>
            <option>RSA</option>
            <option>Diffie-Hellman</option>
            <option>ELGamel</option>
            <option>SHA</option>
        </select>

        <button onclick="encrypt()">Encrypt</button>
        <button onclick="decrypt()">Decrypt</button>

        <label>Cipher Text</label>
        <textarea id="cipher" rows="3"></textarea>
    </div>

    <script>
        /* ----------------------------------------------------
           UTILS
        -----------------------------------------------------*/
        function enc(str) { return new TextEncoder().encode(str); }
        function dec(buf) { return new TextDecoder().decode(buf); }

        function toB64(buf) {
            return btoa(String.fromCharCode(...new Uint8Array(buf)));
        }
        function fromB64(b64) {
            return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        }

        /* ----------------------------------------------------
           CONSTANT AES KEYS (DES + ELGAMAL)
        -----------------------------------------------------*/
        const AES_KEY_RAW = new Uint8Array([
            11, 22, 33, 44, 55, 66, 77, 88, 99, 111, 122, 133, 144, 155, 166, 177,
            188, 199, 210, 220, 230, 240, 12, 34, 56, 78, 90, 123, 145, 167, 189, 201
        ]);

        const ELGAMAL_KEY_RAW = new Uint8Array([
            201, 199, 188, 177, 166, 155, 144, 133, 122, 111, 99, 88, 77, 66, 55, 44,
            33, 22, 11, 5, 9, 12, 50, 80, 99, 140, 180, 200, 220, 230, 240, 250
        ]);

        let AES_KEY, ELGAMAL_KEY;
        let rsaPublicKey, rsaPrivateKey;

        /* ----------------------------------------------------
   SIMPLE, SAFE SYNC "DH" USING BYTES
-----------------------------------------------------*/
        let dh_myPrivate = 7;
        let dh_peerPrivate = 13;

        let dh_myPublic;
        let dh_peerPublic;

        let dh_shared1; // BigInt
        let dh_shared2; // BigInt

        function modPow(base, exp, mod) {
            let B = BigInt(base);
            let E = BigInt(exp);
            let M = BigInt(mod);
            let res = 1n;
            while (E > 0n) {
                if (E & 1n) res = (res * B) % M;
                B = (B * B) % M;
                E >>= 1n;
            }
            return res;
        }

        function initDiffieHellman() {
            const base = 5;
            const prime = 997;
            dh_myPublic = Number(modPow(base, dh_myPrivate, prime));
            dh_peerPublic = Number(modPow(base, dh_peerPrivate, prime));

            dh_shared1 = modPow(dh_peerPublic, dh_myPrivate, prime);
            dh_shared2 = modPow(dh_myPublic, dh_peerPrivate, prime);
            // both are BigInt and should be equal
        }

        /* base64 <-> Uint8Array helpers (safe for any length) */
        function u8ToB64(u8) {
            const CHUNK = 0x8000;
            let str = "";
            for (let i = 0; i < u8.length; i += CHUNK) {
                str += String.fromCharCode(...u8.subarray(i, i + CHUNK));
            }
            return btoa(str);
        }
        function b64ToU8(b64) {
            const bin = atob(b64.replace(/\s+/g, ""));
            const u8 = new Uint8Array(bin.length);
            for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
            return u8;
        }

        /* XOR on raw bytes */
        function xorBytes(u8, keyByte) {
            const out = new Uint8Array(u8.length);
            for (let i = 0; i < u8.length; i++) out[i] = u8[i] ^ keyByte;
            return out;
        }

        /* encrypt/decrypt using proper byte handling */
        function dhEncrypt(text) {
            const encoder = new TextEncoder();
            const pt = encoder.encode(text);               // Uint8Array bytes
            const keyByte = Number(dh_shared1 % 256n);     // single byte key
            const ct = xorBytes(pt, keyByte);
            return u8ToB64(ct);
        }

        function dhDecrypt(cipherText) {
            const decoder = new TextDecoder();
            const ct = b64ToU8(cipherText);
            const keyByte = Number(dh_shared2 % 256n);
            const pt = xorBytes(ct, keyByte);
            return decoder.decode(pt);
        }


        /* ----------------------------------------------------
           INIT KEYS
        -----------------------------------------------------*/
        async function initKeys() {
            AES_KEY = await crypto.subtle.importKey(
                "raw", AES_KEY_RAW, { name: "AES-CBC" }, false, ["encrypt", "decrypt"]
            );

            ELGAMAL_KEY = await crypto.subtle.importKey(
                "raw", ELGAMAL_KEY_RAW, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]
            );

            // RSA STATIC KEYS (unchanged)
            const rsaPubB64 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuG8jpHK6HQs5stjumRZzq7ScTJgPpK4wCCXoUQgyQ6r6N7aA/wI96KXf15FdtcdRAki6VpLLPDv3qJja+Qlad2x/Emhq49BTAceuXmBj3vusmEyjnSW1T1/dunnGaj68h8KRn+t4lACmUsXMDp1TO+4lfZLdJN8tsOe/pKf/WQsDEny3iTQTbKQzw95wf7keWnDu1JcYKVBjGpEivLj88+3DnUyPohStN53ZKw+WBd2QySgaaWkeNfZ6r4unX6bj9vQL9Yt6kMQ4zMWptlwgdBu8lWcRxzAXwrmM9gt5/3cGHK/bizYm2NYAPfZxD7LwmmmJzOTssotJ2nGOdmJPiQIDAQAB";
            const rsaPrivB64 = "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC4byOkcrodCzmy2O6ZFnOrtJxMmA+krjAIJehRCDJDqvo3toD/Aj3opd/XkV21x1ECSLpWkss8O/eomNr5CVp3bH8SaGrj0FMBx65eYGPe+6yYTKOdJbVPX926ecZqPryHwpGf63iUAKZSxcwOnVM77iV9kt0k3y2w57+kp/9ZCwMSfLeJNBNspDPD3nB/uR5acO7UlxgpUGMakSK8uPzz7cOdTI+iFK03ndkrD5YF3ZDJKBppaR419nqvi6dfpuP29Av1i3qQxDjMxam2XCB0G7yVZxHHMBfCuYz2C3n/dwYcr9uLNibY1gA99nEPsvCaaYnM5Oyyi0nacY52Yk+JAgMBAAECggEABq1ypOmVqdq8l0HmoZqzS9KZaUyE6t/dOiF+0v0KlNidgDB8/lg4CMxSQAPLWMfp1VaJjvwRnHfijgAhLXl60dTjy07S6YMJZLvnqRMXipZu6ufoPjBQ62bIW5AJ8J7RqwV1ME0Ra72T4aG3szyO+ISCAJUb3J6xkM4gA8SK9Wl/T7zJNXDCqCoSgGgikY7vgVCDsoNGeb/cMgHOuquy3Om40zajo5/BCXrH3tLp48TeIVjCZo2ZqeYWIFYlux2PDRMb+hw9+wxtxv+IuAuUTaOWK7i6s6ZSFaLESki1abl5fOlStiC5JOjTzMF2PoTMUCcQD+mjr8vvblgwQifJYQKBgQDg8+9K1gKbxlC7wOvEKyitw2vDQ5IpnbWA+YAeEi5Bt6A2npxYWwjEFHQh3Wiyq7Q+jmcTHeVXW72iz2PwYYX3+lersZD5BRGMZrZ9cAe3XyaVvuwiN+k39E0tCt/PqFe0FdByTrV1wUgAf6c6nmtYDEMVafHkZEZwHN54DoCNXwKBgQDR45dVrGvNsFiIUNyaBa+R4RLI2EA1H7j4BgHrq6k03mtQN4oEdGzwmYQGXTucuAegntKTtjIaSI4dyRSW69IlA3SPLHpo7+eUYSuvr68WF2LfyrAZ5dLFUDr4JSaE9r7+0vSDBDPHydWPoGVUeyLd7vkIFvv3O9bM5KDgHzPkFwKBgQC4XFM+QvzqS/L4nVjccf6pwmI8KtHMV5tcc57jhkTwyRx+ByndY+ZgRN8Urg/TdtOG/VBOo47FNMPLfirK5DJWlI5rgWBuJhBGwBtJ3JoGV+4YhdujA62YlRj3FFVvK+mNBt/J/uXK9zgaaIRWj2UsSQhlsWl0pBXyZkaRoFkNAwKBgEinfdVcUBztdFgLlbGDUlkvDi+UG/XHu2Gvwq5vx6zTaVZlQ1Nzcdp/aaJCV8ZSNeG12LLlGMbcYsWQu53al+3UGl8NSHpWwVUtpc+1Auikw8cwBHGSirleomsPgRv5xfez0owfwkTgaxrCrRDnZxRoCrBwNFxKzHo0kjPC2VWVAoGAQpIPBS++JKW6ChHlgPi9N/03UuBybPTjUtD3lHuOBpv1xbvvi5/ZJEodz4+4ZZYW67dKtweWEGIBfEKq+v+b79HRJsFEnHW1uZLeQdPk4tPYp3HaC6TdQgGt7CFRgDSdVLJvdhAe0XxldB3pmaal0aC50eY8xiEyyAUZa5wOD+o=";

            rsaPublicKey = await crypto.subtle.importKey(
                "spki",
                fromB64(rsaPubB64),          // <-- use Uint8Array directly, NOT .buffer
                { name: "RSA-OAEP", hash: "SHA-256" },
                false,
                ["encrypt"]
            );

            rsaPrivateKey = await crypto.subtle.importKey(
                "pkcs8",
                fromB64(rsaPrivB64),         // <-- same here, no .buffer
                { name: "RSA-OAEP", hash: "SHA-256" },
                false,
                ["decrypt"]
            );



            initDiffieHellman();
        }

        /* ----------------------------------------------------
           ENCRYPT
        -----------------------------------------------------*/
        async function encrypt() {
            let text = document.getElementById("plain").value;
            let algo = document.getElementById("algo").value;
            let out = "";

            switch (algo) {

                case "DES": {
                    const iv = crypto.getRandomValues(new Uint8Array(16));
                    const cipher = await crypto.subtle.encrypt(
                        { name: "AES-CBC", iv },
                        AES_KEY,
                        enc(text)
                    );
                    out = toB64(iv) + "|" + toB64(cipher);
                    break;
                }

                case "RSA": {
                    const cipher = await crypto.subtle.encrypt(
                        { name: "RSA-OAEP" },
                        rsaPublicKey,
                        enc(text)
                    );
                    console.log("PUB:", rsaPublicKey);
                    console.log("PRIV:", rsaPrivateKey);

                    out = toB64(cipher);
                    break;
                }

                case "Diffie-Hellman": {
                    out = dhEncrypt(text);
                    break;
                }

                case "ELGamel": {
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const cipher = await crypto.subtle.encrypt(
                        { name: "AES-GCM", iv },
                        ELGAMAL_KEY,
                        enc(text)
                    );
                    out = toB64(iv) + "|" + toB64(cipher);
                    break;
                }

                case "SHA": {
                    const hash = await crypto.subtle.digest("SHA-256", enc(text));
                    out = toB64(hash);
                    break;
                }
            }

            document.getElementById("cipher").value = out;
        }

        /* ----------------------------------------------------
           DECRYPT
        -----------------------------------------------------*/
        async function decrypt() {
            let cipher = document.getElementById("cipher").value;
            let algo = document.getElementById("algo").value;
            let out = "";

            try {
                switch (algo) {

                    case "DES": {
                        const [ivB64, ctB64] = cipher.split("|");
                        const iv = fromB64(ivB64);
                        const ct = fromB64(ctB64);
                        const plain = await crypto.subtle.decrypt(
                            { name: "AES-CBC", iv },
                            AES_KEY,
                            ct
                        );
                        out = dec(plain);
                        break;
                    }

                    case "RSA": {
                        const ct = fromB64(cipher);
                        const plain = await crypto.subtle.decrypt(
                            { name: "RSA-OAEP" },
                            rsaPrivateKey,
                            ct
                        );
                        out = dec(plain);
                        break;
                    }

                    case "Diffie-Hellman": {
                        out = dhDecrypt(cipher);
                        break;
                    }

                    case "ELGamel": {
                        const [ivB64, ctB64] = cipher.split("|");
                        const iv = fromB64(ivB64);
                        const ct = fromB64(ctB64);
                        const plain = await crypto.subtle.decrypt(
                            { name: "AES-GCM", iv },
                            ELGAMAL_KEY,
                            ct
                        );
                        out = dec(plain);
                        break;
                    }

                    case "SHA":
                        out = "Cannot decrypt SHA";
                        break;
                }
            } catch (e) {
                out = "Invalid cipher or corrupted data";
            }

            document.getElementById("plain").value = out;
        }

        /* START */
        initKeys();
    </script>


    <p style="text-align:center; margin-top:20px; font-size:16px;">
        <b>Done by:</b><br>
        A Sri Nimisha - 1DT22CS016<br>
        B R Aditya Vardhan Reddy - 1DT22CS035<br>
        Bhuvan AM - 1DT22CS037<br>
        G Sahaj - 1DT22CS048<br>
    </p>

</body>

</html>
